# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json
# üöÄ GitHub Actions Deployment Workflow
# ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Self-Hosted Runner (Raspberry Pi) ‡πÅ‡∏•‡∏∞ GitHub Secrets Management

name: üöÄ Deploy to Production

on:
  push:
    branches: [main, production]
    paths-ignore:
      - "docs/**"
      - "*.md"
      - ".vscode/**"

  # Manual deployment trigger ‡∏û‡∏£‡πâ‡∏≠‡∏° options
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: "Force rebuild Docker images"
        required: false
        default: false
        type: boolean
      skip_health_checks:
        description: "Skip health checks (for emergency deployments)"
        required: false
        default: false
        type: boolean
      environment:
        description: "Target environment"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging

# üîê Security: ‡∏Å‡∏≥‡∏´‡∏ô‡∏î permissions ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏à‡∏≥‡∏Å‡∏±‡∏î
permissions:
  contents: read
  actions: read
  security-events: write

# üõ°Ô∏è Environment Variables: ‡∏à‡∏≤‡∏Å GitHub Secrets ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
env:
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1
  # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ timezone ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö logs
  TZ: Asia/Bangkok

jobs:
  # Job 1: Security ‡πÅ‡∏•‡∏∞ Environment Validation
  security-check:
    name: üîê Security & Environment Validation
    runs-on: self-hosted
    timeout-minutes: 10

    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üîç Validate Required Secrets
        run: |
          echo "üîê ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö GitHub Secrets ‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô..."

          REQUIRED_SECRETS=(
            "DATABASE_URL"
            "NEXTAUTH_URL"
            "NEXTAUTH_SECRET"
            "JWT_SECRET"
            "INTERNAL_API_KEY"
            "CRON_SECRET"
            "LINE_CLIENT_ID"
            "LINE_CLIENT_SECRET"
            "LINE_LOGIN_CHANNEL_ID"
            "LINE_LOGIN_CHANNEL_SECRET"
            "LINE_CHANNEL_ACCESS"
            "LINE_CHANNEL_SECRET"
            "AIRVISUAL_API_KEY"
            "CMC_API_KEY"
            "OPENAI_API_KEY"
            "APP_DOMAIN"
            "ALLOWED_DOMAINS"
          )

          MISSING_SECRETS=()

          for secret in "${REQUIRED_SECRETS[@]}"; do
            if [[ -z "${!secret}" ]]; then
              MISSING_SECRETS+=("$secret")
            fi
          done

          if [[ ${#MISSING_SECRETS[@]} -gt 0 ]]; then
            echo "‚ùå Missing required secrets:"
            printf '%s\n' "${MISSING_SECRETS[@]}"
            echo "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ GitHub Secrets ‡πÉ‡∏ô Repository Settings"
            exit 1
          fi

          echo "‚úÖ All required secrets are configured"
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          NEXTAUTH_URL: ${{ secrets.NEXTAUTH_URL }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          INTERNAL_API_KEY: ${{ secrets.INTERNAL_API_KEY }}
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
          LINE_CLIENT_ID: ${{ secrets.LINE_CLIENT_ID }}
          LINE_CLIENT_SECRET: ${{ secrets.LINE_CLIENT_SECRET }}
          LINE_LOGIN_CHANNEL_ID: ${{ secrets.LINE_LOGIN_CHANNEL_ID }}
          LINE_LOGIN_CHANNEL_SECRET: ${{ secrets.LINE_LOGIN_CHANNEL_SECRET }}
          LINE_CHANNEL_ACCESS: ${{ secrets.LINE_CHANNEL_ACCESS }}
          LINE_CHANNEL_SECRET: ${{ secrets.LINE_CHANNEL_SECRET }}
          AIRVISUAL_API_KEY: ${{ secrets.AIRVISUAL_API_KEY }}
          CMC_API_KEY: ${{ secrets.CMC_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          APP_DOMAIN: ${{ secrets.APP_DOMAIN }}
          ALLOWED_DOMAINS: ${{ secrets.ALLOWED_DOMAINS }}

      - name: üñ•Ô∏è System Resource Check
        run: |
          echo "üñ•Ô∏è ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö system resources..."

          # Memory check
          AVAILABLE_MEMORY=$(free -m | awk 'NR==2{printf "%.0f", $7}')
          REQUIRED_MEMORY=1024

          if [[ $AVAILABLE_MEMORY -lt $REQUIRED_MEMORY ]]; then
            echo "‚ö†Ô∏è Warning: Available memory: ${AVAILABLE_MEMORY}MB (recommended: ${REQUIRED_MEMORY}MB+)"
          else
            echo "‚úÖ Memory: ${AVAILABLE_MEMORY}MB available"
          fi

          # Disk space check
          AVAILABLE_DISK=$(df -BM /var/lib/docker 2>/dev/null | awk 'NR==2{print $4}' | sed 's/M//' || echo "1000")
          REQUIRED_DISK=2048

          if [[ $AVAILABLE_DISK -lt $REQUIRED_DISK ]]; then
            echo "‚ùå Insufficient disk space: ${AVAILABLE_DISK}MB (required: ${REQUIRED_DISK}MB+)"
            exit 1
          else
            echo "‚úÖ Disk space: ${AVAILABLE_DISK}MB available"
          fi

          # Docker service check
          if ! systemctl is-active --quiet docker; then
            echo "‚ùå Docker service is not running"
            exit 1
          fi
          echo "‚úÖ Docker service is running"

      - name: üßπ Pre-deployment Cleanup
        run: |
          echo "üßπ ‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏° deployment..."

          # ‡∏•‡∏ö dangling images ‡πÅ‡∏•‡∏∞ unused volumes
          docker image prune -f || true
          docker volume prune -f || true

          # ‡∏•‡∏ö build cache ‡πÄ‡∏Å‡πà‡∏≤ (‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ß‡πâ 24 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á)
          docker builder prune --filter "until=24h" -f || true

          echo "‚úÖ Cleanup completed"

  # Job 2: Build ‡πÅ‡∏•‡∏∞ Deploy
  deploy:
    name: üöÄ Build & Deploy Application
    runs-on: self-hosted
    needs: security-check
    timeout-minutes: 30

    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: üíæ Create Backup of Current State
        run: |
          echo "üíæ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏≥‡∏£‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô..."

          # ‡∏™‡∏£‡πâ‡∏≤‡∏á backup directory with timestamp
          BACKUP_DIR="/tmp/backup-$(date +%Y%m%d-%H%M%S)"
          mkdir -p "$BACKUP_DIR"

          # Backup current docker images (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
          if docker images | grep -q "bun-line-t3"; then
            echo "Creating image backup..."
            docker save -o "$BACKUP_DIR/current-images.tar" \
              $(docker images --format "{{.Repository}}:{{.Tag}}" | grep "bun-line-t3" | head -5)
            echo "‚úÖ Docker images backed up"
          else
            echo "‚ÑπÔ∏è No existing images to backup"
          fi

          # Backup docker-compose state
          docker-compose config > "$BACKUP_DIR/docker-compose-state.yml" 2>/dev/null || true

          # Save backup path for later use
          echo "BACKUP_DIR=$BACKUP_DIR" >> $GITHUB_ENV
          echo "‚úÖ Backup created at: $BACKUP_DIR"

      - name: üîß Setup Environment File
        run: |
          echo "üîß ‡∏™‡∏£‡πâ‡∏≤‡∏á .env.prod ‡∏à‡∏≤‡∏Å GitHub Secrets..."

          cat > .env.prod << EOF
          # =============================================================================
          # Environment Configuration (Generated from GitHub Secrets)
          # Generated at: $(date -Iseconds)
          # Commit: ${{ github.sha }}
          # =============================================================================

          # Application Environment
          APP_ENV=production
          NEXT_PUBLIC_APP_ENV=production
          HOSTNAME=localhost
          PORT=${{ secrets.PORT || '12914' }}
          FRONTEND_URL="${{ secrets.NEXTAUTH_URL }}/"

          # =============================================================================
          # Authentication & Security
          # =============================================================================

          # NextAuth Configuration
          NEXTAUTH_URL="${{ secrets.NEXTAUTH_URL }}"
          NEXTAUTH_SECRET="${{ secrets.NEXTAUTH_SECRET }}"
          JWT_SECRET="${{ secrets.JWT_SECRET }}"
          JWT_EXPIRES_IN=18144000000

          # Internal API Security
          INTERNAL_API_KEY="${{ secrets.INTERNAL_API_KEY }}"

          # Cron Job Security
          CRON_SECRET="${{ secrets.CRON_SECRET }}"

          # =============================================================================
          # LINE Integration
          # =============================================================================

          # LINE Login Provider
          LINE_CLIENT_ID="${{ secrets.LINE_CLIENT_ID }}"
          LINE_CLIENT_SECRET="${{ secrets.LINE_CLIENT_SECRET }}"
          LINE_LOGIN_CHANNEL_ID="${{ secrets.LINE_LOGIN_CHANNEL_ID }}"
          LINE_LOGIN_CHANNEL_SECRET="${{ secrets.LINE_LOGIN_CHANNEL_SECRET }}"

          # LINE Messaging API
          LINE_CHANNEL_ACCESS="${{ secrets.LINE_CHANNEL_ACCESS }}"
          LINE_MESSAGING_API=https://api.line.me/v2/bot/message
          LINE_GET_CONTENT=https://api-data.line.me/v2/bot/message
          LINE_CHANNEL_SECRET="${{ secrets.LINE_CHANNEL_SECRET }}"

          # =============================================================================
          # Database Configuration
          # =============================================================================

          # MongoDB
          MONGODB_URI="${{ secrets.DATABASE_URL }}"
          DATABASE_URL="${{ secrets.DATABASE_URL }}"
          DB_NAME=linebot

          # =============================================================================
          # External API Keys
          # =============================================================================

          # Air Quality Monitoring
          AIRVISUAL_API_KEY="${{ secrets.AIRVISUAL_API_KEY }}"

          # Cryptocurrency Market Data
          CMC_API_KEY="${{ secrets.CMC_API_KEY }}"
          CMC_URL=https://pro-api.coinmarketcap.com

          # OpenAI API Configuration
          OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}"

          # =============================================================================
          # Domain Security Configuration
          # =============================================================================

          # Application Domain & Security
          APP_DOMAIN="${{ secrets.APP_DOMAIN }}"
          ALLOWED_DOMAINS="${{ secrets.ALLOWED_DOMAINS }}"
          EOF

          # Set secure permissions
          chmod 600 .env.prod
          echo "‚úÖ Environment file created with secure permissions"

      - name: üèóÔ∏è Build Application
        id: build_app
        continue-on-error: true
        run: |
          echo "üèóÔ∏è Building application..."

          # Force rebuild ‡∏ñ‡πâ‡∏≤ manual trigger ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
          BUILD_ARGS=""
          if [[ "${{ github.event.inputs.force_rebuild }}" == "true" ]]; then
            echo "üîÑ Force rebuild enabled - pulling base images..."
            BUILD_ARGS="--pull --no-cache"
          fi

          # ‡∏™‡πà‡∏á build arguments ‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö Docker build
          if docker-compose build $BUILD_ARGS \
            --build-arg DATABASE_URL="${{ secrets.DATABASE_URL }}" \
            --build-arg NEXTAUTH_URL="${{ secrets.NEXTAUTH_URL }}" \
            --build-arg NEXTAUTH_SECRET="${{ secrets.NEXTAUTH_SECRET }}" \
            --build-arg OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}" \
            --build-arg APP_DOMAIN="${{ secrets.APP_DOMAIN }}" \
            --build-arg ALLOWED_DOMAINS="${{ secrets.ALLOWED_DOMAINS }}"; then
            echo "‚úÖ Build completed successfully"
            echo "BUILD_SUCCESS=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Build failed"
            echo "BUILD_SUCCESS=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: üîÑ Rollback on Build Failure
        if: steps.build_app.outcome == 'failure'
        run: |
          echo "üîÑ Build ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß! ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥ rollback..."

          # üîç ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö environment variables ‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
          if [[ -z "$DATABASE_URL" || -z "$NEXTAUTH_URL" || -z "$NEXTAUTH_SECRET" ]]; then
            echo "‚ùå ‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö‡∏ß‡πà‡∏≤ environment variables ‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡πÇ‡∏´‡∏•‡∏î"
            echo "üîß ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö GitHub Secrets configuration"
            exit 1
          fi

          # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ backup ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
          if [[ -f "$BACKUP_DIR/current-images.tar" ]]; then
            echo "üì¶ Restoring previous Docker images..."
            docker load -i "$BACKUP_DIR/current-images.tar"

            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ .env.prod ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà ‡πÅ‡∏•‡∏∞‡πÇ‡∏´‡∏•‡∏î‡πÉ‡∏´‡πâ docker-compose
            if [[ -f ".env.prod" ]]; then
              echo "üîß Using existing .env.prod for rollback..."
              # Restart services with previous images ‡πÅ‡∏•‡∏∞ environment variables
              docker-compose --env-file .env.prod down --timeout 30 || true
              docker-compose --env-file .env.prod up -d
            else
              echo "‚ö†Ô∏è No .env.prod found, using environment variables directly..."
              # Restart services with previous images
              docker-compose down --timeout 30 || true
              docker-compose up -d
            fi

            echo "‚úÖ Rollback completed - services restored to previous version"
            echo "üîó Application should be accessible at: ${{ secrets.NEXTAUTH_URL }}"
          else
            echo "‚ö†Ô∏è No backup found - this might be the first deployment"
            echo "üîß ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö configuration ‡πÅ‡∏•‡∏∞‡∏•‡∏≠‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á"
          fi

          # ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å workflow ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ fail (‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÑ‡∏î‡πâ rollback ‡πÅ‡∏•‡πâ‡∏ß)
          echo "::warning::Build failed but rollback completed successfully"
          exit 1
        env:
          # üîê Environment variables ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö rollback
          PORT: ${{ secrets.PORT || '12914' }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          NEXTAUTH_URL: ${{ secrets.NEXTAUTH_URL }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          INTERNAL_API_KEY: ${{ secrets.INTERNAL_API_KEY }}
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
          LINE_CLIENT_ID: ${{ secrets.LINE_CLIENT_ID }}
          LINE_CLIENT_SECRET: ${{ secrets.LINE_CLIENT_SECRET }}
          LINE_LOGIN_CHANNEL_ID: ${{ secrets.LINE_LOGIN_CHANNEL_ID }}
          LINE_LOGIN_CHANNEL_SECRET: ${{ secrets.LINE_LOGIN_CHANNEL_SECRET }}
          LINE_CHANNEL_ACCESS: ${{ secrets.LINE_CHANNEL_ACCESS }}
          LINE_CHANNEL_SECRET: ${{ secrets.LINE_CHANNEL_SECRET }}
          AIRVISUAL_API_KEY: ${{ secrets.AIRVISUAL_API_KEY }}
          CMC_API_KEY: ${{ secrets.CMC_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          APP_DOMAIN: ${{ secrets.APP_DOMAIN }}
          ALLOWED_DOMAINS: ${{ secrets.ALLOWED_DOMAINS }}

      - name: üõë Stop Existing Services
        if: steps.build_app.outputs.BUILD_SUCCESS == 'true'
        run: |
          echo "üõë ‡∏´‡∏¢‡∏∏‡∏î‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà..."

          # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö services ‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏î‡πâ‡∏ß‡∏¢ timeout protection
          if timeout 10 docker-compose ps 2>/dev/null | grep -q "Up" 2>/dev/null; then
            echo "Stopping existing services..."
            docker-compose down --timeout 30 || true
          else
            echo "No running services found or docker-compose not responding"
          fi

      - name: üöÄ Start Services
        id: start_services
        if: steps.build_app.outputs.BUILD_SUCCESS == 'true'
        run: |
          echo "üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£..."

          # Start services with new images
          if docker-compose up -d; then
            echo "‚úÖ Services started successfully"
            echo "SERVICES_STARTED=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Failed to start services"
            echo "SERVICES_STARTED=false" >> $GITHUB_OUTPUT
            exit 1
          fi
        env:
          # Override environment variables ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö docker-compose
          PORT: ${{ secrets.PORT || '12914' }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          NEXTAUTH_URL: ${{ secrets.NEXTAUTH_URL }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          INTERNAL_API_KEY: ${{ secrets.INTERNAL_API_KEY }}
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
          LINE_CLIENT_ID: ${{ secrets.LINE_CLIENT_ID }}
          LINE_CLIENT_SECRET: ${{ secrets.LINE_CLIENT_SECRET }}
          LINE_LOGIN_CHANNEL_ID: ${{ secrets.LINE_LOGIN_CHANNEL_ID }}
          LINE_LOGIN_CHANNEL_SECRET: ${{ secrets.LINE_LOGIN_CHANNEL_SECRET }}
          LINE_CHANNEL_ACCESS: ${{ secrets.LINE_CHANNEL_ACCESS }}
          LINE_CHANNEL_SECRET: ${{ secrets.LINE_CHANNEL_SECRET }}
          AIRVISUAL_API_KEY: ${{ secrets.AIRVISUAL_API_KEY }}
          CMC_API_KEY: ${{ secrets.CMC_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          APP_DOMAIN: ${{ secrets.APP_DOMAIN }}
          ALLOWED_DOMAINS: ${{ secrets.ALLOWED_DOMAINS }}

      - name: üè• Quick Health Check After Startup
        id: health_check
        if: steps.start_services.outputs.SERVICES_STARTED == 'true'
        continue-on-error: true
        run: |
          echo "üè• ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û‡πÄ‡∏ö‡∏∑‡πâ‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£..."

          # Wait for services to be ready
          sleep 20

          # Check if containers are running with timeout protection
          if ! timeout 10 docker-compose ps 2>/dev/null | grep -q "Up" 2>/dev/null; then
            echo "‚ùå Containers are not running properly or docker-compose not responding"
            echo "üìã Attempting to get container status directly..."
            docker ps --filter "name=bun-line-t3" || true
            echo "HEALTH_CHECK_PASSED=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Test basic connectivity with retries
          PORT="${{ secrets.PORT || '12914' }}"
          MAX_ATTEMPTS=5
          ATTEMPT=1

          while [[ $ATTEMPT -le $MAX_ATTEMPTS ]]; do
            echo "Health check attempt $ATTEMPT/$MAX_ATTEMPTS..."

            if curl -f -s -m 10 "http://localhost:$PORT/api/health" > /dev/null 2>&1; then
              echo "‚úÖ Basic health check passed"
              echo "HEALTH_CHECK_PASSED=true" >> $GITHUB_OUTPUT
              exit 0
            else
              if [[ $ATTEMPT -eq $MAX_ATTEMPTS ]]; then
                echo "‚ö†Ô∏è Health check endpoint not responding after $MAX_ATTEMPTS attempts"
                echo "HEALTH_CHECK_PASSED=false" >> $GITHUB_OUTPUT
                exit 1
              fi
              sleep 5
              ((ATTEMPT++))
            fi
          done

      - name: üîÑ Rollback on Startup or Health Check Failure
        if: steps.health_check.outcome == 'failure' || steps.start_services.outcome == 'failure'
        run: |
          echo "üîÑ ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏´‡∏£‡∏∑‡∏≠ health check ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß! ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥ rollback..."

          # üîç ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö environment variables ‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
          if [[ -z "$DATABASE_URL" || -z "$NEXTAUTH_URL" || -z "$NEXTAUTH_SECRET" ]]; then
            echo "‚ùå ‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö‡∏ß‡πà‡∏≤ environment variables ‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡πÇ‡∏´‡∏•‡∏î"
            echo "üîß ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö GitHub Secrets configuration"
            exit 1
          fi

          # Stop current failed deployment
          echo "üõë Stopping failed deployment..."
          docker-compose down --timeout 30 || true

          # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ backup ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
          if [[ -f "$BACKUP_DIR/current-images.tar" ]]; then
            echo "üì¶ Restoring previous Docker images..."
            docker load -i "$BACKUP_DIR/current-images.tar"

            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ .env.prod ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà ‡πÅ‡∏•‡∏∞‡πÇ‡∏´‡∏•‡∏î‡πÉ‡∏´‡πâ docker-compose
            if [[ -f ".env.prod" ]]; then
              echo "üîß Using existing .env.prod for rollback..."
              # Restart services with previous images ‡πÅ‡∏•‡∏∞ environment variables
              docker-compose --env-file .env.prod up -d
            else
              echo "‚ö†Ô∏è No .env.prod found, using environment variables directly..."
              # Restart services with previous images
              docker-compose up -d
            fi

            # Wait and check if rollback was successful
            sleep 15
            if docker-compose ps | grep -q "Up"; then
              echo "‚úÖ Rollback completed successfully"
              echo "üîó Previous version restored and accessible at: ${{ secrets.NEXTAUTH_URL }}"

              # Quick verification that rollback worked
              sleep 10
              if curl -f -s -m 10 "http://localhost:${{ secrets.PORT || '12914' }}/api/health" > /dev/null 2>&1; then
                echo "‚úÖ Rollback verification: Application is healthy"
              else
                echo "‚ö†Ô∏è Rollback verification: Health check failed but containers are running"
              fi
            else
              echo "‚ùå Rollback failed - containers not starting"
              echo "üîß Manual intervention required - checking logs..."
              docker-compose logs --tail=50
              exit 1
            fi
          else
            echo "‚ö†Ô∏è No backup found - this might be the first deployment"
            echo "üîß First deployment failed - please check configuration and try again"
            echo "üìã Current container status:"
            docker-compose ps
            echo "üìã Recent logs:"
            docker-compose logs --tail=30
            exit 1
          fi

          # Mark as warning (deployment failed but rollback succeeded)
          echo "::warning::Deployment failed but rollback completed successfully. Previous version is running."
          exit 1
        env:
          # üîê Environment variables ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö rollback
          PORT: ${{ secrets.PORT || '12914' }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          NEXTAUTH_URL: ${{ secrets.NEXTAUTH_URL }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          INTERNAL_API_KEY: ${{ secrets.INTERNAL_API_KEY }}
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
          LINE_CLIENT_ID: ${{ secrets.LINE_CLIENT_ID }}
          LINE_CLIENT_SECRET: ${{ secrets.LINE_CLIENT_SECRET }}
          LINE_LOGIN_CHANNEL_ID: ${{ secrets.LINE_LOGIN_CHANNEL_ID }}
          LINE_LOGIN_CHANNEL_SECRET: ${{ secrets.LINE_LOGIN_CHANNEL_SECRET }}
          LINE_CHANNEL_ACCESS: ${{ secrets.LINE_CHANNEL_ACCESS }}
          LINE_CHANNEL_SECRET: ${{ secrets.LINE_CHANNEL_SECRET }}
          AIRVISUAL_API_KEY: ${{ secrets.AIRVISUAL_API_KEY }}
          CMC_API_KEY: ${{ secrets.CMC_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          APP_DOMAIN: ${{ secrets.APP_DOMAIN }}
          ALLOWED_DOMAINS: ${{ secrets.ALLOWED_DOMAINS }}

      - name: üßπ Cleanup Old Backup
        if: steps.health_check.outputs.HEALTH_CHECK_PASSED == 'true'
        run: |
          echo "üßπ ‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• backup ‡πÄ‡∏Å‡πà‡∏≤..."

          # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ backup directories ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
          if ls /tmp/backup-* >/dev/null 2>&1; then
            # ‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô backup ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
            TOTAL_BACKUPS=$(ls -1d /tmp/backup-* 2>/dev/null | wc -l)
            echo "‚ÑπÔ∏è Found $TOTAL_BACKUPS backup directories"
            
            # ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 3 ‡∏ï‡∏±‡∏ß ‡πÉ‡∏´‡πâ‡∏•‡∏ö‡∏≠‡∏±‡∏ô‡πÄ‡∏Å‡πà‡∏≤
            if [ "$TOTAL_BACKUPS" -gt 3 ]; then
              echo "Removing old backups (keeping 3 newest)..."
              # ‡πÉ‡∏ä‡πâ stat ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏•‡πâ‡∏ß‡∏•‡∏ö‡∏≠‡∏±‡∏ô‡πÄ‡∏Å‡πà‡∏≤
              cd /tmp && for dir in backup-*; do 
                stat -f "%m %N" "$dir" 2>/dev/null
              done | sort -nr | tail -n +4 | cut -d' ' -f2- | while read -r backup_dir; do
                echo "Removing old backup: $backup_dir"
                rm -rf "$backup_dir" 2>/dev/null || true
              done
            fi
            
            # ‡πÅ‡∏™‡∏î‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô backup ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠
            REMAINING_BACKUPS=$(ls -1d /tmp/backup-* 2>/dev/null | wc -l)
            echo "‚ÑπÔ∏è Remaining backups: $REMAINING_BACKUPS"
            ls -1t /tmp/backup-* 2>/dev/null | head -3
          else
            echo "‚ÑπÔ∏è No backup directories found to clean up"
          fi

          echo "‚úÖ Old backups cleaned up"

      - name: üéâ Deployment Success Summary
        if: steps.health_check.outputs.HEALTH_CHECK_PASSED == 'true'
        run: |
          echo "üéâ Deployment ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!"
          echo "üìÖ Deployed at: $(date -Iseconds)"
          echo "üîñ Commit: ${{ github.sha }}"
          echo "üåø Branch: ${{ github.ref_name }}"
          echo "üë§ Triggered by: ${{ github.actor }}"
          echo "üîó Application URL: ${{ secrets.NEXTAUTH_URL }}"

          echo "üê≥ Container Status:"
          docker-compose ps --format "table {{.Name}}\t{{.State}}\t{{.Ports}}"

          echo "üìä Resource Usage:"
          docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}"

          echo "‚úÖ Deployment pipeline completed successfully with rollback protection!"

      - name: üîê Security Cleanup
        if: always()
        run: |
          echo "üîê ‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç..."

          # ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå environment variables ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
          if [[ -f .env.prod ]]; then
            shred -vfz -n 3 .env.prod
            echo "‚úÖ Environment file securely deleted"
          fi

          # ‡∏•‡πâ‡∏≤‡∏á environment variables ‡∏à‡∏≤‡∏Å shell history
          unset DATABASE_URL NEXTAUTH_SECRET LINE_CHANNEL_SECRET LINE_CHANNEL_ACCESS
          unset AIRVISUAL_API_KEY CMC_API_KEY ENCRYPTION_KEY HMAC_SECRET

          echo "‚úÖ Security cleanup completed"

  # Job 3: Health Checks ‡πÅ‡∏•‡∏∞ Monitoring
  monitor:
    name: üè• Health Checks & Monitoring
    runs-on: self-hosted
    needs: deploy
    timeout-minutes: 10
    if: github.event.inputs.skip_health_checks != 'true'

    steps:
      - name: ‚è±Ô∏è Wait for Service Startup
        run: |
          echo "‚è±Ô∏è ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô..."
          sleep 30

      - name: üè• Application Health Check
        run: |
          echo "üè• ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û‡πÅ‡∏≠‡∏õ‡∏û‡∏•‡∏¥‡πÄ‡∏Ñ‡∏ä‡∏±‡∏ô..."

          HEALTH_URL="http://localhost:${{ secrets.PORT || '12914' }}/api/health"
          MAX_ATTEMPTS=10
          ATTEMPT=1

          while [[ $ATTEMPT -le $MAX_ATTEMPTS ]]; do
            echo "Health check attempt $ATTEMPT/$MAX_ATTEMPTS..."

            if curl -f -s -m 10 "$HEALTH_URL" > /dev/null; then
              echo "‚úÖ Application is healthy"
              break
            else
              if [[ $ATTEMPT -eq $MAX_ATTEMPTS ]]; then
                echo "‚ùå Application health check failed after $MAX_ATTEMPTS attempts"
                docker-compose logs --tail=50
                exit 1
              fi
              echo "‚è≥ Waiting 10 seconds before retry..."
              sleep 10
              ((ATTEMPT++))
            fi
          done

      - name: üîç Service Status Check
        run: |
          echo "üîç ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£..."

          # Check container status with timeout and error handling
          if ! timeout 15 docker-compose ps 2>/dev/null | grep -E "(Up|healthy)" 2>/dev/null; then
            echo "‚ùå Services are not running properly or not responding"
            echo "üìã Attempting alternative status check..."
            docker ps --filter "name=bun-line-t3" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" || true
            echo "üìã Recent logs:"
            timeout 30 docker-compose logs --tail=100 2>/dev/null || docker logs $(docker ps -q --filter "name=bun-line-t3") --tail=50 2>/dev/null || true
            exit 1
          fi

          echo "‚úÖ All services are running"

      - name: üìä Resource Usage Report
        run: |
          echo "üìä ‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£..."

          echo "=== Docker Container Stats ==="
          docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.MemPerc}}"

          echo "=== System Resource Usage ==="
          echo "Memory Usage:"
          free -h

          echo "Disk Usage:"
          df -h /var/lib/docker

          echo "‚úÖ Resource report completed"

      - name: üìù Deployment Summary
        run: |
          echo "üìù ‡∏™‡∏£‡∏∏‡∏õ‡∏Å‡∏≤‡∏£ deployment..."

          echo "üéâ Deployment completed successfully!"
          echo "üìÖ Deployed at: $(date -Iseconds)"
          echo "üîñ Commit: ${{ github.sha }}"
          echo "üåø Branch: ${{ github.ref_name }}"
          echo "üë§ Triggered by: ${{ github.actor }}"
          echo "üîó Application URL: ${{ secrets.NEXTAUTH_URL }}"

          # Container information
          echo "üê≥ Running containers:"
          docker-compose ps --format "table {{.Name}}\t{{.State}}\t{{.Ports}}"

  # Job 4: Post-deployment Verification (‡πÄ‡∏â‡∏û‡∏≤‡∏∞ production)
  verify:
    name: ‚úÖ Post-deployment Verification
    runs-on: self-hosted
    needs: monitor
    timeout-minutes: 5
    if: github.ref == 'refs/heads/main' && github.event.inputs.skip_health_checks != 'true'

    steps:
      - name: üîç LINE Bot Health Check
        run: |
          echo "üîç ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û LINE Bot..."

          # Test webhook endpoint (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ test endpoint)
          WEBHOOK_URL="http://localhost:${{ secrets.PORT || '12914' }}/api/line"

          if curl -f -s -m 10 -X POST "$WEBHOOK_URL" \
             -H "Content-Type: application/json" \
             -d '{"events":[],"destination":"test"}' > /dev/null; then
            echo "‚úÖ LINE Bot webhook is responsive"
          else
            echo "‚ö†Ô∏è LINE Bot webhook test failed (may be normal for production)"
          fi

      - name: üìß Notification (Future Enhancement)
        run: |
          echo "üìß ‡∏™‡πà‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô deployment ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à..."
          echo "‚ÑπÔ∏è ‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏ô‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï (LINE Notify, Slack, etc.)"
